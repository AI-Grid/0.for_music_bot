import os
import asyncio
from typing import Dict, Any, Optional
from camoufox import AsyncCamoufox
from playwright.async_api import expect
from configs.browser_config import config


async def review_song_with_ai(audio_file_path: str, song_structure: Dict[str, Any]) -> Dict[str, Any]:
    """
    Review a song using AI Studio to check for quality issues.
    
    Args:
        audio_file_path: Path to the audio file to review
        song_structure: Dictionary containing the song structure with lyrics
        
    Returns:
        Dictionary containing the review results and verdict
    """
    try:
        # Validate audio file exists
        if not os.path.exists(audio_file_path):
            return {
                "success": False,
                "error": f"Audio file not found at path: {audio_file_path}",
                "verdict": "error"
            }

        async with AsyncCamoufox(
            headless=False,
            persistent_context=True,
            user_data_dir="backend/camoufox_session_data",
            os=("windows"),
            config=config,
            humanize=True,
            main_world_eval=True,
            geoip=True,
            i_know_what_im_doing=True,
        ) as browser:
            page = await browser.new_page(locale="en-US")
            
            # Navigate to AI Studio
            await page.goto(
                "https://aistudio.google.com/prompts/new_chat",
                wait_until="domcontentloaded",
                timeout=30000,
            )

            await page.wait_for_timeout(2000)
            await page.wait_for_load_state("load")

            # Login process
            email_input = page.locator('input[type="email"]')
            await email_input.wait_for(state="visible", timeout=10000)
            await email_input.fill("pbNJ1sznC2Gr@gmail.com")
            await page.keyboard.press("Enter")

            password_input = page.locator('input[name="Passwd"]')
            await password_input.wait_for(state="visible", timeout=10000)
            await password_input.fill("&!8G26tlbsgO")
            await page.keyboard.press("Enter")

            await page.wait_for_url("https://aistudio.google.com/prompts/new_chat", timeout=20000)
            await page.mouse.click(10, 10)

            # Wait for prompt textarea
            prompt_textarea_selector = 'textarea[aria-label="Type something or tab to choose an example prompt"]'
            await page.locator(prompt_textarea_selector).wait_for(state="visible", timeout=30000)

            # Upload audio file
            add_button = page.locator('button[aria-label="Insert assets such as images, videos, files, or audio"]')
            await add_button.wait_for(state="visible", timeout=10000)
            await add_button.click()
            await page.wait_for_timeout(1000)

            try:
                file_input_locator = page.locator('input[type="file"]')
                await file_input_locator.wait_for(state="attached", timeout=5000)
                await file_input_locator.set_input_files(audio_file_path)
            except Exception as e:
                return {
                    "success": False,
                    "error": f"Failed to upload audio file: {str(e)}",
                    "verdict": "error"
                }

            # Handle acknowledge button if present
            try:
                acknowledge_bttn = page.locator('span:has-text("Acknowledge")')
                await acknowledge_bttn.wait_for(state="visible", timeout=2000)
                if await acknowledge_bttn.is_visible():
                    await acknowledge_bttn.click()
            except:
                pass  # Acknowledge button may not appear

            # First prompt - transcription and initial review
            prompt_textarea = page.locator(prompt_textarea_selector)
            await prompt_textarea.wait_for(state="visible", timeout=5000)
            
            first_prompt = """This is a song generated by AI and we need to check it's quality. The AI has a tendency of making a few common mistakes. Please write out the lyrics that you hear and note what is spoken and what is rapped, and what is sung. If the song is unclear or sounds messy and unmusical, the song needs to be deleted and remade. If it is more than 30% spoken it needs to be deleted and remade. If it cuts off abruptly and doesnt resolve naturally, it needs to be deleted and remade, and if the song feels like it ends, but then it picks back up again, it needs to be deleted and remade. Please write out the lyrics as requested and let me know if any red flags require the song to be deleted and remade. Don't attempt to recognize the lyrics source and infer what they should be, just write what you hear without inference or adjustment. If a word doesn't make sense, just spell it out phonetically. Add final verdict by ending with 'Final Verdict: [re-roll] or [continue]'."""
            
            await prompt_textarea.fill(first_prompt)

            # Focus textarea and run first prompt
            box = await prompt_textarea.bounding_box()
            if box:
                x = box["x"] + box["width"] / 2
                y = box["y"] + box["height"] / 2
                await page.mouse.click(x, y)

            run_bttn = page.locator('button[aria-label="Run"]')
            await expect(run_bttn).to_be_enabled(timeout=20000)

            # Handle overlay if present
            overlay_selector = "div.cdk-overlay-backdrop.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing"
            overlay = page.locator(overlay_selector)
            try:
                await overlay.wait_for(state="hidden", timeout=10000)
            except:
                await page.keyboard.press("Escape")
                await page.wait_for_timeout(500)

            await run_bttn.click(timeout=15000)
            await page.wait_for_timeout(60000)

            # Get first AI response
            ai_response = page.locator("ms-text-chunk.ng-star-inserted").last
            await ai_response.wait_for(state="visible", timeout=30000)
            first_response = await ai_response.inner_text()

            # Second prompt - compare with intended lyrics
            try:
                prompt_textarea = page.locator('textarea[aria-label="Start typing a prompt"]')
                await prompt_textarea.wait_for(state="visible", timeout=20000)

                # Format song structure for comparison
                formatted_lyrics = _format_song_structure_for_prompt(song_structure)
                
                second_prompt = f"""You are our primary proofreader, and we need to confirm the AI has not made any mistakes with our lyrics while singing. Below, I will give you the intended lyrics for the song, please compare them to the lyrics you transcribed above for inaccuracies.

Converted song structure verses: {song_structure}

{formatted_lyrics}

We are looking for things that don't match which indicates the song must be deleted and remade. Our goal is to go verse by verse and stay perfectly in order without skipping or adjusting or repeating. If the song has adlibs near the start, this is acceptable. If the song repeats a single sentence or a few words directly after that sentence or phrase has been said, this is an acceptable creative decision. If the song fully completes the lyrics, any repetition that comes after is acceptable as long as the lyrics were completely sung through at least once fully in order. Since some words may not have been recognized by you, if you notice that a word is spelled differently, but with similar phonetics, assume that the word is correct and you just misheard before. Please tell me if the song needs to be deleted and remade, or if it is safe to keep.

Add final verdict by ending with 'Final Verdict: [re-roll] or [continue]'."""

                await prompt_textarea.fill(second_prompt)

                run_bttn = page.locator('button[aria-label="Run"]')
                await expect(run_bttn).to_be_enabled(timeout=20000)

                # Handle overlay again
                try:
                    await overlay.wait_for(state="hidden", timeout=10000)
                except:
                    await page.keyboard.press("Escape")
                    await page.wait_for_timeout(500)

                await run_bttn.click(timeout=15000)
                await page.wait_for_timeout(60000)

                # Get second AI response
                ai_response = page.locator("ms-text-chunk.ng-star-inserted").last
                await ai_response.wait_for(state="visible", timeout=30000)
                second_response = await ai_response.inner_text()

                # Determine final verdict
                verdict = "continue"
                if "[re-roll]" in second_response.lower():
                    verdict = "re-roll"
                elif "[continue]" in second_response.lower():
                    verdict = "continue"

                return {
                    "success": True,
                    "first_response": first_response,
                    "second_response": second_response,
                    "verdict": verdict,
                    "audio_file": audio_file_path
                }

            except Exception as e:
                return {
                    "success": False,
                    "error": f"Second prompt failed: {str(e)}",
                    "first_response": first_response,
                    "verdict": "error"
                }

    except Exception as e:
        return {
            "success": False,
            "error": f"Review process failed: {str(e)}",
            "verdict": "error"
        }


def _format_song_structure_for_prompt(song_structure: Dict[str, Any]) -> str:
    """
    Format song structure dictionary into readable lyrics format for the AI prompt.
    
    Args:
        song_structure: Dictionary containing song sections and lyrics
        
    Returns:
        Formatted string with lyrics organized by sections
    """
    formatted_lines = []
    
    for section_name, verses in song_structure.items():
        formatted_lines.append(f"[{section_name}]:")
        
        if isinstance(verses, dict):
            for verse_num, lyrics in verses.items():
                formatted_lines.append(lyrics.strip())
        elif isinstance(verses, str):
            formatted_lines.append(verses.strip())
        
        formatted_lines.append("")  # Add blank line between sections
    
    return "\n".join(formatted_lines)